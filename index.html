<script>
  (function(){
    const slidesContainer = document.getElementById('slides');
    if (!slidesContainer) return;
    const imgs = Array.from(slidesContainer.querySelectorAll('img'));
    const n = Math.max(imgs.length, 1);

    // set flex-basis on each image
    imgs.forEach(img => {
      img.style.flex = '0 0 ' + (100 / n) + '%';
    });

    // set container width to match count
    slidesContainer.style.width = (n * 100) + '%';

    // Remove any previously inline animation so we can set a fresh one
    slidesContainer.style.animation = '';

    // Create a minimal keyframes rule that translates from 0% to final offset.
    // We'll use animation-timing-function: steps(n) so the animation advances exactly
    // one discrete step per slide (equal duration for each image).
    const keyframes = `@keyframes slide {
      0%   { transform: translateX(0%); }
      100% { transform: translateX(-${(n - 1) * 100}%); }
    }`;

    const style = document.createElement('style');
    style.setAttribute('data-generated-by', 'slideshow-script');
    style.innerHTML = keyframes;
    document.head.appendChild(style);

    // Choose duration per slide (seconds). Adjust perSlideSeconds to taste.
    const perSlideSeconds = 4; // seconds each slide is visible
    const totalDuration = n * perSlideSeconds;

    // Use steps(n, jump-none) timing so each slide is held for the same interval and the transform jumps
    // discretely between slides rather than performing short transitions that can look like "fly by".
    // jump-none ensures all n slides (including first and last positions) are held for equal duration.
    slidesContainer.style.animation = `slide ${totalDuration}s steps(${n}, jump-none) infinite`;

    // (Optional) If you want a small smooth crossfade rather than a hard step, you can
    // change to 'linear' and generate more precise keyframes â€” but steps() is simplest and robust.
  })();
</script>